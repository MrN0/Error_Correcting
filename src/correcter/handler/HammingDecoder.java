package correcter.handler;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * This class is the "Hamming Code (7,4)" decoder.
 */
public class HammingDecoder extends AbstractDataHandler {

    @Override
    public void handle(String inputFile, String outputFile) throws IOException {
        readFileAsByteArray(inputFile);
        printDataViews(inputFile,
                "hex view: " + hexView(),
                "bin view: " + binView());

        fixErrors();
        String fixed = binView();
        decode();

        writeToFile(outputFile);
        printDataViews(outputFile,
                "correct: " + fixed,
                "decode: " + binView(),
                "hex view: " + hexView(),
                "text view: " + textView());
    }

    /**
     * This method fixes errors in the byte array
     */
    private void fixErrors() {
        for (int i = 0; i < this.data.length; i++) {
            this.data[i] = fixByte(this.data[i]);
        }
    }

    /**
     * This method decodes the encoded Hamming Code array
     */
    private void decode() {
        List<Byte> expandedBytes = new ArrayList<>();
        byte decodedByte = 0;
        boolean firstHalfOfByte = true;
        for (byte aByte : this.data) {
            byte bits = getBitsFromExpandedByte(aByte);
            decodedByte += bits;
            if (firstHalfOfByte) {
                decodedByte <<= 4;
            } else {
                expandedBytes.add(decodedByte);
                decodedByte = 0;
            }
            firstHalfOfByte = !firstHalfOfByte;
        }
        this.data = toByteArray(expandedBytes);
    }

    /**
     * This method fixes an error in the specified byte
     *
     * @param aByte the byte to fix
     * @return      the fixed byte
     */
    private byte fixByte(byte aByte) {
        int bitsInByte = 8;
        int parityIndex = 1;

        byte error = -1;
        while (parityIndex < bitsInByte) {
            byte parity = calculateParity(aByte, parityIndex);
            byte possibleErrors = possibleErrors(parityIndex);
            boolean noErrors = parity == (aByte >> bitsInByte - parityIndex & 1);
            error = (byte) (noErrors ? error & ~possibleErrors : error & possibleErrors);
            parityIndex *= 2;
        }
        return (byte) (aByte ^ error);
    }

    /**
     * This method calculates a given parity in a given byte
     *
     * @param aByte         the byte to calculate
     * @param parityIndex   the parity index
     * @return              the calculated parity
     */
    private byte calculateParity(byte aByte, int parityIndex) {
        int bitsInByte = 8;
        int nextSegment = parityIndex * 2;
        boolean parityBit = true;

        byte calculatedParity = 0;
        // segments of parity bits
        for (int i = parityIndex; i < bitsInByte; i += nextSegment) {
            // sequence of bits for calculation
            for (int j = 0; j < parityIndex; j++) {
                // skip the first bit which is the parity bit
                if (parityBit) {
                    parityBit = false;
                } else {
                    int position = bitsInByte - i - j;
                    calculatedParity ^= aByte >> position & 1;
                }
            }
        }
        return  calculatedParity;
    }

    /**
     * This method generates possible errors in the byte relative to the parity bit
     *
     * @param parityIndex   the parity index
     * @return              the generated byte with possible errors
     */
    private byte possibleErrors(int parityIndex) {
        int bitsInByte = 8;
        int nextSegment = parityIndex * 2;

        byte errors = 0;
        // segments of parity bits
        for (int i = parityIndex; i < bitsInByte; i += nextSegment) {
            // sequence of bits for calculation
            for (int j = 0; j < parityIndex; j++) {
                int position = bitsInByte - i - j;
                errors ^= 1 << position;
            }
        }
        return errors;
    }

    /**
     * This method extracts the required bits from the expanded
     * byte and places them in the first four byte bits.
     *
     * @param aByte the expanded byte
     * @return      the byte with extracted bits
     */
    private byte getBitsFromExpandedByte(byte aByte) {
        int bitsInByte = 8;
        int parityIndex = 1;

        byte bits = 0;
        for (int i = 1; i <= bitsInByte; i++) {
            // skip the parity bit
            if (parityIndex == i) {
                parityIndex *= 2;
            } else {
                byte bit = (byte) (aByte >> bitsInByte - i & 1);
                bits = (byte) (bits + bit << 1);
            }
        }
        return (byte) (bits >> 1);
    }

}
